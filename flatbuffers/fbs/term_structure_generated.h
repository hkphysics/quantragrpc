// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TERMSTRUCTURE_QUANTRA_H_
#define FLATBUFFERS_GENERATED_TERMSTRUCTURE_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

#include "curve_points_generated.h"
#include "enums_generated.h"

namespace quantra {

struct TermStructure;
struct TermStructureBuilder;

struct TermStructure FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TermStructureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DAY_COUNTER = 6,
    VT_INTERPOLATOR = 8,
    VT_BOOTSTRAP_TRAIT = 10,
    VT_POINTS_TYPE = 12,
    VT_POINTS = 14,
    VT_AS_OF_DATE = 16
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::Interpolator interpolator() const {
    return static_cast<quantra::enums::Interpolator>(GetField<int8_t>(VT_INTERPOLATOR, 0));
  }
  quantra::enums::BootstrapTrait bootstrap_trait() const {
    return static_cast<quantra::enums::BootstrapTrait>(GetField<int8_t>(VT_BOOTSTRAP_TRAIT, 0));
  }
  const flatbuffers::Vector<uint8_t> *points_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_POINTS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *points() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_POINTS);
  }
  const flatbuffers::String *as_of_date() const {
    return GetPointer<const flatbuffers::String *>(VT_AS_OF_DATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER) &&
           VerifyField<int8_t>(verifier, VT_INTERPOLATOR) &&
           VerifyField<int8_t>(verifier, VT_BOOTSTRAP_TRAIT) &&
           VerifyOffset(verifier, VT_POINTS_TYPE) &&
           verifier.VerifyVector(points_type()) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           VerifyPointVector(verifier, points(), points_type()) &&
           VerifyOffset(verifier, VT_AS_OF_DATE) &&
           verifier.VerifyString(as_of_date()) &&
           verifier.EndTable();
  }
};

struct TermStructureBuilder {
  typedef TermStructure Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(TermStructure::VT_ID, id);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(TermStructure::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_interpolator(quantra::enums::Interpolator interpolator) {
    fbb_.AddElement<int8_t>(TermStructure::VT_INTERPOLATOR, static_cast<int8_t>(interpolator), 0);
  }
  void add_bootstrap_trait(quantra::enums::BootstrapTrait bootstrap_trait) {
    fbb_.AddElement<int8_t>(TermStructure::VT_BOOTSTRAP_TRAIT, static_cast<int8_t>(bootstrap_trait), 0);
  }
  void add_points_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> points_type) {
    fbb_.AddOffset(TermStructure::VT_POINTS_TYPE, points_type);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> points) {
    fbb_.AddOffset(TermStructure::VT_POINTS, points);
  }
  void add_as_of_date(flatbuffers::Offset<flatbuffers::String> as_of_date) {
    fbb_.AddOffset(TermStructure::VT_AS_OF_DATE, as_of_date);
  }
  explicit TermStructureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TermStructure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TermStructure>(end);
    return o;
  }
};

inline flatbuffers::Offset<TermStructure> CreateTermStructure(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Interpolator interpolator = quantra::enums::Interpolator_BackwardFlat,
    quantra::enums::BootstrapTrait bootstrap_trait = quantra::enums::BootstrapTrait_Discount,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> points_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> points = 0,
    flatbuffers::Offset<flatbuffers::String> as_of_date = 0) {
  TermStructureBuilder builder_(_fbb);
  builder_.add_as_of_date(as_of_date);
  builder_.add_points(points);
  builder_.add_points_type(points_type);
  builder_.add_id(id);
  builder_.add_bootstrap_trait(bootstrap_trait);
  builder_.add_interpolator(interpolator);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

inline flatbuffers::Offset<TermStructure> CreateTermStructureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Interpolator interpolator = quantra::enums::Interpolator_BackwardFlat,
    quantra::enums::BootstrapTrait bootstrap_trait = quantra::enums::BootstrapTrait_Discount,
    const std::vector<uint8_t> *points_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *points = nullptr,
    const char *as_of_date = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto points_type__ = points_type ? _fbb.CreateVector<uint8_t>(*points_type) : 0;
  auto points__ = points ? _fbb.CreateVector<flatbuffers::Offset<void>>(*points) : 0;
  auto as_of_date__ = as_of_date ? _fbb.CreateString(as_of_date) : 0;
  return quantra::CreateTermStructure(
      _fbb,
      id__,
      day_counter,
      interpolator,
      bootstrap_trait,
      points_type__,
      points__,
      as_of_date__);
}

inline const quantra::TermStructure *GetTermStructure(const void *buf) {
  return flatbuffers::GetRoot<quantra::TermStructure>(buf);
}

inline const quantra::TermStructure *GetSizePrefixedTermStructure(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<quantra::TermStructure>(buf);
}

inline bool VerifyTermStructureBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<quantra::TermStructure>(nullptr);
}

inline bool VerifySizePrefixedTermStructureBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<quantra::TermStructure>(nullptr);
}

inline void FinishTermStructureBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<quantra::TermStructure> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTermStructureBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<quantra::TermStructure> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_TERMSTRUCTURE_QUANTRA_H_
