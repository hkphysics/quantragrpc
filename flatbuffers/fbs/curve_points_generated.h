// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CURVEPOINTS_QUANTRA_H_
#define FLATBUFFERS_GENERATED_CURVEPOINTS_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

#include "enums_generated.h"

namespace quantra {

struct Deposit;
struct DepositBuilder;

struct FRA;
struct FRABuilder;

struct Future;
struct FutureBuilder;

struct Swap;
struct SwapBuilder;

enum Point : uint8_t {
  Point_NONE = 0,
  Point_Deposit = 1,
  Point_FRA = 2,
  Point_Future = 3,
  Point_Swap = 4,
  Point_MIN = Point_NONE,
  Point_MAX = Point_Swap
};

inline const Point (&EnumValuesPoint())[5] {
  static const Point values[] = {
    Point_NONE,
    Point_Deposit,
    Point_FRA,
    Point_Future,
    Point_Swap
  };
  return values;
}

inline const char * const *EnumNamesPoint() {
  static const char * const names[6] = {
    "NONE",
    "Deposit",
    "FRA",
    "Future",
    "Swap",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoint(Point e) {
  if (flatbuffers::IsOutRange(e, Point_NONE, Point_Swap)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoint()[index];
}

template<typename T> struct PointTraits {
  static const Point enum_value = Point_NONE;
};

template<> struct PointTraits<quantra::Deposit> {
  static const Point enum_value = Point_Deposit;
};

template<> struct PointTraits<quantra::FRA> {
  static const Point enum_value = Point_FRA;
};

template<> struct PointTraits<quantra::Future> {
  static const Point enum_value = Point_Future;
};

template<> struct PointTraits<quantra::Swap> {
  static const Point enum_value = Point_Swap;
};

bool VerifyPoint(flatbuffers::Verifier &verifier, const void *obj, Point type);
bool VerifyPointVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Deposit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DepositBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_TENOR_TIME_UNIT = 6,
    VT_TENOR_NUMBER = 8,
    VT_FIXING_DAYS = 10,
    VT_CALENDAR = 12,
    VT_BUSINESS_DAY_CONVENTION = 14,
    VT_DAY_COUNTER = 16
  };
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 0));
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 0);
  }
  int32_t fixing_days() const {
    return GetField<int32_t>(VT_FIXING_DAYS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATE) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FIXING_DAYS) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER) &&
           verifier.EndTable();
  }
};

struct DepositBuilder {
  typedef Deposit Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rate(float rate) {
    fbb_.AddElement<float>(Deposit::VT_RATE, rate, 0.0f);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(Deposit::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(Deposit::VT_TENOR_NUMBER, tenor_number, 0);
  }
  void add_fixing_days(int32_t fixing_days) {
    fbb_.AddElement<int32_t>(Deposit::VT_FIXING_DAYS, fixing_days, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(Deposit::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(Deposit::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(Deposit::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  explicit DepositBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Deposit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Deposit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Deposit> CreateDeposit(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rate = 0.0f,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    int32_t tenor_number = 0,
    int32_t fixing_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  DepositBuilder builder_(_fbb);
  builder_.add_fixing_days(fixing_days);
  builder_.add_tenor_number(tenor_number);
  builder_.add_rate(rate);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  builder_.add_tenor_time_unit(tenor_time_unit);
  return builder_.Finish();
}

struct FRA FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FRABuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_MONTHS_TO_START = 6,
    VT_MONTHS_TO_END = 8,
    VT_FIXING_DAYS = 10,
    VT_CALENDAR = 12,
    VT_BUSINESS_DAY_CONVENTION = 14,
    VT_DAY_COUNTER = 16
  };
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  int32_t months_to_start() const {
    return GetField<int32_t>(VT_MONTHS_TO_START, 0);
  }
  int32_t months_to_end() const {
    return GetField<int32_t>(VT_MONTHS_TO_END, 0);
  }
  int32_t fixing_days() const {
    return GetField<int32_t>(VT_FIXING_DAYS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATE) &&
           VerifyField<int32_t>(verifier, VT_MONTHS_TO_START) &&
           VerifyField<int32_t>(verifier, VT_MONTHS_TO_END) &&
           VerifyField<int32_t>(verifier, VT_FIXING_DAYS) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER) &&
           verifier.EndTable();
  }
};

struct FRABuilder {
  typedef FRA Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rate(float rate) {
    fbb_.AddElement<float>(FRA::VT_RATE, rate, 0.0f);
  }
  void add_months_to_start(int32_t months_to_start) {
    fbb_.AddElement<int32_t>(FRA::VT_MONTHS_TO_START, months_to_start, 0);
  }
  void add_months_to_end(int32_t months_to_end) {
    fbb_.AddElement<int32_t>(FRA::VT_MONTHS_TO_END, months_to_end, 0);
  }
  void add_fixing_days(int32_t fixing_days) {
    fbb_.AddElement<int32_t>(FRA::VT_FIXING_DAYS, fixing_days, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(FRA::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(FRA::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(FRA::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  explicit FRABuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FRA> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FRA>(end);
    return o;
  }
};

inline flatbuffers::Offset<FRA> CreateFRA(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rate = 0.0f,
    int32_t months_to_start = 0,
    int32_t months_to_end = 0,
    int32_t fixing_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  FRABuilder builder_(_fbb);
  builder_.add_fixing_days(fixing_days);
  builder_.add_months_to_end(months_to_end);
  builder_.add_months_to_start(months_to_start);
  builder_.add_rate(rate);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

struct Future FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FutureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_FUTURE_START_DATE = 6,
    VT_FUTURE_MONTHS = 8,
    VT_CALENDAR = 10,
    VT_BUSINESS_DAY_CONVENTION = 12,
    VT_DAY_COUNTER = 14
  };
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  const flatbuffers::String *future_start_date() const {
    return GetPointer<const flatbuffers::String *>(VT_FUTURE_START_DATE);
  }
  int32_t future_months() const {
    return GetField<int32_t>(VT_FUTURE_MONTHS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATE) &&
           VerifyOffset(verifier, VT_FUTURE_START_DATE) &&
           verifier.VerifyString(future_start_date()) &&
           VerifyField<int32_t>(verifier, VT_FUTURE_MONTHS) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER) &&
           verifier.EndTable();
  }
};

struct FutureBuilder {
  typedef Future Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rate(float rate) {
    fbb_.AddElement<float>(Future::VT_RATE, rate, 0.0f);
  }
  void add_future_start_date(flatbuffers::Offset<flatbuffers::String> future_start_date) {
    fbb_.AddOffset(Future::VT_FUTURE_START_DATE, future_start_date);
  }
  void add_future_months(int32_t future_months) {
    fbb_.AddElement<int32_t>(Future::VT_FUTURE_MONTHS, future_months, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(Future::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(Future::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(Future::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  explicit FutureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Future> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Future>(end);
    return o;
  }
};

inline flatbuffers::Offset<Future> CreateFuture(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rate = 0.0f,
    flatbuffers::Offset<flatbuffers::String> future_start_date = 0,
    int32_t future_months = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  FutureBuilder builder_(_fbb);
  builder_.add_future_months(future_months);
  builder_.add_future_start_date(future_start_date);
  builder_.add_rate(rate);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

inline flatbuffers::Offset<Future> CreateFutureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rate = 0.0f,
    const char *future_start_date = nullptr,
    int32_t future_months = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  auto future_start_date__ = future_start_date ? _fbb.CreateString(future_start_date) : 0;
  return quantra::CreateFuture(
      _fbb,
      rate,
      future_start_date__,
      future_months,
      calendar,
      business_day_convention,
      day_counter);
}

struct Swap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SwapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_TENOR_TIME_UNIT = 6,
    VT_TENOR_NUMBER = 8,
    VT_CALENDAR = 10,
    VT_SW_FIXED_LEG_FREQUENCY = 12,
    VT_SW_FIXED_LEG_CONVENTION = 14,
    VT_SW_FIXED_LEG_DAY_COUNTER = 16,
    VT_SW_FLOATING_LEG_INDEX = 18,
    VT_SPREAD = 20,
    VT_FWD_START_DAYS = 22
  };
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 0));
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::Frequency sw_fixed_leg_frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_SW_FIXED_LEG_FREQUENCY, 0));
  }
  quantra::enums::BusinessDayConvention sw_fixed_leg_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_SW_FIXED_LEG_CONVENTION, 0));
  }
  quantra::enums::DayCounter sw_fixed_leg_day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_SW_FIXED_LEG_DAY_COUNTER, 0));
  }
  quantra::enums::Ibor sw_floating_leg_index() const {
    return static_cast<quantra::enums::Ibor>(GetField<int8_t>(VT_SW_FLOATING_LEG_INDEX, 0));
  }
  float spread() const {
    return GetField<float>(VT_SPREAD, 0.0f);
  }
  int32_t fwd_start_days() const {
    return GetField<int32_t>(VT_FWD_START_DAYS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATE) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR) &&
           VerifyField<int8_t>(verifier, VT_SW_FIXED_LEG_FREQUENCY) &&
           VerifyField<int8_t>(verifier, VT_SW_FIXED_LEG_CONVENTION) &&
           VerifyField<int8_t>(verifier, VT_SW_FIXED_LEG_DAY_COUNTER) &&
           VerifyField<int8_t>(verifier, VT_SW_FLOATING_LEG_INDEX) &&
           VerifyField<float>(verifier, VT_SPREAD) &&
           VerifyField<int32_t>(verifier, VT_FWD_START_DAYS) &&
           verifier.EndTable();
  }
};

struct SwapBuilder {
  typedef Swap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rate(float rate) {
    fbb_.AddElement<float>(Swap::VT_RATE, rate, 0.0f);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(Swap::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(Swap::VT_TENOR_NUMBER, tenor_number, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(Swap::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_sw_fixed_leg_frequency(quantra::enums::Frequency sw_fixed_leg_frequency) {
    fbb_.AddElement<int8_t>(Swap::VT_SW_FIXED_LEG_FREQUENCY, static_cast<int8_t>(sw_fixed_leg_frequency), 0);
  }
  void add_sw_fixed_leg_convention(quantra::enums::BusinessDayConvention sw_fixed_leg_convention) {
    fbb_.AddElement<int8_t>(Swap::VT_SW_FIXED_LEG_CONVENTION, static_cast<int8_t>(sw_fixed_leg_convention), 0);
  }
  void add_sw_fixed_leg_day_counter(quantra::enums::DayCounter sw_fixed_leg_day_counter) {
    fbb_.AddElement<int8_t>(Swap::VT_SW_FIXED_LEG_DAY_COUNTER, static_cast<int8_t>(sw_fixed_leg_day_counter), 0);
  }
  void add_sw_floating_leg_index(quantra::enums::Ibor sw_floating_leg_index) {
    fbb_.AddElement<int8_t>(Swap::VT_SW_FLOATING_LEG_INDEX, static_cast<int8_t>(sw_floating_leg_index), 0);
  }
  void add_spread(float spread) {
    fbb_.AddElement<float>(Swap::VT_SPREAD, spread, 0.0f);
  }
  void add_fwd_start_days(int32_t fwd_start_days) {
    fbb_.AddElement<int32_t>(Swap::VT_FWD_START_DAYS, fwd_start_days, 0);
  }
  explicit SwapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Swap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Swap>(end);
    return o;
  }
};

inline flatbuffers::Offset<Swap> CreateSwap(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rate = 0.0f,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    int32_t tenor_number = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::Frequency sw_fixed_leg_frequency = quantra::enums::Frequency_Annual,
    quantra::enums::BusinessDayConvention sw_fixed_leg_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter sw_fixed_leg_day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Ibor sw_floating_leg_index = quantra::enums::Ibor_Euribor10M,
    float spread = 0.0f,
    int32_t fwd_start_days = 0) {
  SwapBuilder builder_(_fbb);
  builder_.add_fwd_start_days(fwd_start_days);
  builder_.add_spread(spread);
  builder_.add_tenor_number(tenor_number);
  builder_.add_rate(rate);
  builder_.add_sw_floating_leg_index(sw_floating_leg_index);
  builder_.add_sw_fixed_leg_day_counter(sw_fixed_leg_day_counter);
  builder_.add_sw_fixed_leg_convention(sw_fixed_leg_convention);
  builder_.add_sw_fixed_leg_frequency(sw_fixed_leg_frequency);
  builder_.add_calendar(calendar);
  builder_.add_tenor_time_unit(tenor_time_unit);
  return builder_.Finish();
}

inline bool VerifyPoint(flatbuffers::Verifier &verifier, const void *obj, Point type) {
  switch (type) {
    case Point_NONE: {
      return true;
    }
    case Point_Deposit: {
      auto ptr = reinterpret_cast<const quantra::Deposit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_FRA: {
      auto ptr = reinterpret_cast<const quantra::FRA *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_Future: {
      auto ptr = reinterpret_cast<const quantra::Future *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_Swap: {
      auto ptr = reinterpret_cast<const quantra::Swap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPointVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPoint(
        verifier,  values->Get(i), types->GetEnum<Point>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_CURVEPOINTS_QUANTRA_H_
